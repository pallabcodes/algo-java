## All Math: Ratio and proportions, LCM, HCF and GCD, Euclid's Algorithm, Factorial, Prime no, Logarithms, Sieve of Eratosthenes, Fibonacci Sequence, Quadratic equations (done), Set, Relation and function, Matrix, Graph (basic) and vector, Arithmetic progression and geometric progression, permutation and combination, linear equation, boolean algebra, statistics and probability (basic), calculus 1, bitwise operators and number theory, geometry and trigonometry

## SDE Essential: Boolean Algebra & Logic, Linear Equation, Statistics and Probability (basic), Geometry and Trigonometry

N.B: All essential Math topics needed (especially for Software development) are within `discrete math` & so it's enough.

## Good to know: Number Theory and prime numbers (including Sieve of Eratosthenes), Fibonacci Sequence, Euclid's Algorithm, LCF and HCF and Logarithms

## specific domain: Matrix, Graph (basic) and Vector, Calculus-1, AP, GP, Set, Relation and Function

## Animation: Geometry, Trigonometry, Linear Algebra and Interpolation and Easing Function

## ALL Math: Discrete Math(Fundamental 2), Number theory (DS), Algebra(Fundamental 1), Liner algebra (ML), Mathematical Induction (Recursion), Basic Probability and Statistic (ML), Graph Theory(DS), Boolean Algebra, Calculus(ML and Simulation), Solving Equations(DS), Logarithms(DS), Functions solving (DS), Prime numbers, GP and AP, Geometry and Trigonometry, Exponential(DS), Modulus(DS), Factorial(DS), Recurrence Relation and Series (DS: Recursion), Matrices and Matrix operations (DS)

[[##]] Prerequisites of Integration: Algebra + discrete math + basic calculus -> Integrations

[[##]] Prerequisites of Recurrence Relation: Basic Principles of Sequence and series -> Summation and series formulas -> Inductive Reasoning and Mathematical Induction -> Number Theory -> Generating Functions -> Newton's method (for value of p)

# Q: What type of recursion and what kind of recurrence relation it has? [ An approach is selected based on these two ]

Reminder: There's no single math topic that can handle all types of recursion, depending on "recursion type" and "recurrence relations"; the different approach is required

## Recursive functions/Recurrence relations: Master Theorem (divide and conquer recursions) or Akra-Bazzi (same and versatile)

https://www.youtube.com/watch?v=DTERgFa9jJc&ab_channel=Mathispower4u
https://www.youtube.com/watch?v=l5BG_c62CCo&ab_channel=itechnica
https://www.youtube.com/watch?v=honkPbYEc7Q&ab_channel=randerson112358
https://www.youtube.com/watch?v=7mhvA5L7KqY&ab_channel=TrevTutor
https://www.youtube.com/watch?v=OgNH3xrhtdg&ab_channel=MathFortress
https://www.youtube.com/watch?v=5zi5eG5Ui-Y&ab_channel=AcademicLesson
https://www.youtube.com/watch?v=PUB0TaZ7bhA&ab_channel=TheOrganicChemistryTutor

[[##]] Algorithms and complexity: it isn't a math topic but a concept i.e. Big O Notation

## MATH: Discrete Math + Linear Algebra is enough for DSA (VVIP) and optional basic probalities and statistics and basic graph and basic calculus

## upper bound: maximum time or space to be take by the algo (it won't be more than that never) or in a sorted array if given a target the first greater element than target [1, 2, 3, 4, 5] target = 2; upper bound here is 3

## lower bound: minimum time or space by algorithm and in a sorted array first less element [1, 2, 3, 4, 5] t = 3; lower = 2

## worst time complexities based on the given input's length

## leetcoding: take note of specific algo being used for specific problems and patterns

#### https://levelup.gitconnected.com/dont-just-leetcode-follow-the-coding-patterns-instead-4beb6a197fdb

#### https://www.techinterviewhandbook.org/algorithms/array/

+, - , \*, /, %, bitwise, Math.log(), Math.pow(), Math.sqrt(), Math.min(), Math.max(), Math.min()

-- Prime numbers, Hermonic progression of prime numbers,

---

Array(ArrayList), String, Stack/Queue, LinkedList, Binary Search Tree, Heap, Graph and Trie

#### solving: what are the steps and its cases? how: programmatically possible (VILA) + Mathematically possible + assumption

#### concept memorization + mix and match for any new problem by mapping it any previous concept(s) or question(s)

#### How to actually solve (or try to solve) leetcode new (and unique) problems?

Discrete mathematics - Susana Epp or Kohlmann
Number theory- Joseph silver man
Graph theory- Richard Trudeu
Combinatorics-Alan tucker
Algorithms -Jeff Erickson or Dasgupta or grokking

1. Concept memorization (not code) e.g how Binary search truly works and when should I used it (and its template)

2. and this is what will help solve/brainstorm new problems along with below a, b

a. Best leetcode questions to understand specific algorithmic technique e.g. backtracking / BFS / DFS, Matrix Traversal, merge sort etc.
b. Most common leetcode patterns when the input is string

# Top 5 data structures to must do: 1) Graph 2) Stack / Queue 3) HashMap 4) Binary Tree 5) Heap

# Top 5 algorithm to must do: 1) BFS and DFS (BT & Graph) 2) DP 3) Backtracking 4) Sliding Window 5) Top K elements

## when to use (main data structure) Heap with Binary Tree (helper data structure)? when to use Binary Tree with hashmap?



#### Generalized Steps to solve any programming problem: https://www.youtube.com/watch?v=roanIWKtGMY&t=358s&ab_channel=NeetCodeIO

1. *Understanding problem (I can imagine/map it to the real world situation i.e. related/unrelated strictly + visualize) + *test or simplified inputs + time constraints (skip or not) + keywords (if given)

2. Is output explicit or implicit? Some answer is explicitly given (or part of the input), otherwise need to find the output (visually) and when doing it I will be able to find out STEP(s) and required algo/patterns `This is a must STEP`

N.B: [ during the STEP 2 if stuck i.e. can't get to the output with my approach(es) (that could be vary for each person e.g. 10/15/20/30min ]; write comments on things I am unable to solve & now straight up look for solution â†“ 

N.B: Even If I look at the solution; I must ensure 2 things 1) why developer opt for this (data structure and algo) in this way to solve my commented queries? 2) Understand enough to apply to another problem later (although this may or may not another problem like this)

3. Divide the problem into smaller ones or individual steps and each step could utilize (a. example inputs b. are helper/additional data structure(s)/algo(s) needed? c. possible cases and edge cases d. pseudocode)

4. Get Unstuck - Fix Bugs/Errors (even if i need to look at solution a. why does the solution work? b. what could be the intuition/thought process to come up with this solution?)

5. If you really want to think like a programmer 


https://www.youtube.com/watch?v=e6wWDe7_-Ag&ab_channel=MisoTech%28MichaelSong%29 (VVIP)
https://chat.openai.com/c/9c5fa7fd-71a0-488c-ba64-b54dbfa92494 (VVIP)

## Design a real problem: making my own question and deciding what data structure and algorithm to be used there (it could be related to a project or standalone question)

requirement@hdfcergo.com
proposal no = 202403120182258

## How to build intuition ?

ask chatgpt: since "Numbers with same consecutive differences" question doesn't really explicitly say anything about to use DFS, how should I build to intuition or think to use DFS + backtracking?

ask chatgpt: Understand the Benefits of DFS and Backtracking like this list out the benefits of all and most common data structure and their relative algorithms/leetcode and when they are used especially when the question doesn't say anything explicitly

ask chatgpt: Understand the Benefits of DFS and Backtracking like this list out the benefits of all and most common algorithms/leetcode and when they are used especially when the question doesn't say anything explicitly



These are my opinions.
* My first thought on this is. If you can sort without moving those in the banned position. Though that was wrong.

1.) The importance of simplifying or making a problem understandable.
I bet most people spend 30 mins or more just figuring out the problem statement.
1.2) The importance of naming things.  
Like maybe banned is actually called banned_index or k should be called differently.
2.) Good examples are a must. I don't know if this is hard because of bad examples or bad because of too few good examples.
3.) Companies should understand not everyone wants to be a competitive programmer or want to be a leetcode solver.
It's fine if you want it. But don't make it a priority for qualification.
DS and Algo should be priotize more.
4.) The benefit for the problem. If you give this type of problem to your applicants. Is there a benefit if someone solves this problem?
Or are you just giving hard problem for the sake of it? If your company always or most of the times encounter this problem go for it.
But if not, it is just a waste of time for you and your applicants.


